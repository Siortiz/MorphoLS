from astropy.io import ascii, fits
from astropy.table import Table
from astropy.stats import sigma_clipped_stats
from astropy.nddata import NDData, CCDData
from photutils.psf import extract_stars, EPSFBuilder
from astropy.wcs import WCS
from utils import filter_sel
from ejecutable import L
import numpy as np
import astropy.units as u
import os

#L = Table.read('/home/seba/Documents/DECALS/Galaxies/Galaxies_DECALS_186.csv')
Datos_L = L.group_by('Group')
GL = Datos_L.groups.keys
#filtros = filter_sel(Datos_L['Group'][0])
#print(filtros)
def psf_maker(grupo, filtro):
    hdu = fits.open(f'/home/seba/Documents/DECALS/joined_bricks/{grupo}/{grupo}_image_{filtro}.fits')
    data=hdu[0].data
    source_catalog = ascii.read(f'/home/seba/Documents/MorphoLS/sex/group_{grupo}')
    stars = source_catalog[(source_catalog['FLUX_RADIUS'] < 3) & (source_catalog['MAG_AUTO'] < 22)]
    x_sex = source_catalog['X_IMAGE']
    y_sex = source_catalog['Y_IMAGE']
    x = stars['X_IMAGE']
    y = stars['Y_IMAGE']
    snr = stars['SNR_WIN']
    #Para no considerar las estrellas de los bordes
    
    size_box = 40
    hsize = (size_box) - 1/2
    mask = ((x > hsize) & (x < (data.shape[1] -1 - hsize)) & (y > hsize) & (y <   (data.shape[0] -1 - hsize)))
    x=x[mask]
    y=y[mask]
    snr=snr[mask]
    selected_x = []
    selected_y = []
    selected_snr = []
    # Itera sobre cada estrella y verifica si hay otras estrellas dentro de la misma caja
    for i in range(len(x)):
    # Coordenadas de la estrella actual
        x_star = x[i]
        y_star = y[i]
        snr_star = snr[i]
    
    # Define los límites de la caja alrededor de la estrella
        x_min = int(x_star - hsize)
        x_max = int(x_star + hsize)
        y_min = int(y_star - hsize)
        y_max = int(y_star + hsize)
    
    # Verifica si hay otras estrellas dentro de la caja
        other_stars_inside = any((x_sex[j] >= x_min and x_sex[j] <= x_max and y_sex[j] >= y_min and y_sex[j] <= y_max) for j in range(len(x_sex)) if x_sex[j] != x[i])
    
    # Si no hay otras estrellas dentro de la caja, agrega la estrella actual a las seleccionadas
        if not other_stars_inside:
            selected_x.append(x_star)
            selected_y.append(y_star)
            selected_snr.append(snr_star)

    # Crea una nueva tabla con las estrellas seleccionadas
    stars_tbl = Table()
    stars_tbl['x'] = selected_x
    stars_tbl['y'] = selected_y
    stars_tbl['SNR'] = selected_snr


    stars_tbl = stars_tbl[(stars_tbl['SNR'] > 750) & (stars_tbl['SNR'] < 25000)]
    print(len(stars_tbl))
    #Extraer el background de la imagen
    
    image = CCDData.read(f'/home/seba/Documents/DECALS/joined_bricks/{grupo}/{grupo}_image_{filtro}.fits', unit='adu')
    mean_val, median_val, std_val = sigma_clipped_stats(image.data, sigma=3.0)
    data -= median_val
    nddata = NDData(data=data)

    #Extraer estrellas
    
    extracted_stars = extract_stars(nddata, stars_tbl, size=39)
    
    #Calcular la psf
    
    epsf_builder = EPSFBuilder(oversampling=4, maxiters=3, progress_bar=True)
    epsf, fitted_stars = epsf_builder(extracted_stars)

    hdu_psf = fits.PrimaryHDU(epsf.data)
    hdul_psf = fits.HDUList([hdu_psf])
    hdul_psf.writeto(f'Field_Img/psf/psf_group_{grupo}_{filtro}.fits', overwrite=True)
    
    return

def mask(grupo):
    #Coordenadas a posiciones
    hdu = fits.open(f'Field_Img/det/det_group_{grupo}.fits')
    hdur = hdu[0].header
    wcs = WCS(header=hdu[0].header)
    X_0 = hdur['CRPIX1']
    Y_0 = hdur['CRPIX2']
    RA_0 = hdur['CRVAL1']*u.degree
    DEC_0 = hdur['CRVAL2']*u.degree
    delta = np.abs(hdur['CDELT1'])*u.degree
    X = []
    Y = []
    for i in range(len(Datos_L)):
        RA = Datos_L['ra'][i]*u.degree
        DEC = Datos_L['dec'][i]*u.degree
        (X_new, Y_new) = wcs.all_world2pix(RA, DEC, 1)
        X.append(X_new)
        Y.append(Y_new)
    X=np.array(X)
    Y=np.array(Y)
    #Desenmascarar fuentes
    fig = fits.open(f'Field_Img/det/det_group_{grupo}_seg.fits')
    
    # Obtener datos de la imagen y crear una copia para modificar
    data = fig[0].data
    header = fig[0].header
    
    # Crear matrices de índices para la imagen completa
    y_indices, x_indices = np.indices(data.shape)
    
    # Iterar sobre cada posición de fuente
    for i in range(len(X)):
        # Calcular la distancia euclidiana a partir de (X[i], Y[i])
        distances = np.sqrt((x_indices - X[i])**2 + (y_indices - Y[i])**2)
        
        # Encontrar la posición con la menor distancia que coincida con el valor de la fuente
        min_dist_idx = np.argmin(distances)
        min_y, min_x = np.unravel_index(min_dist_idx, data.shape)
        
        # Desenmascarar el punto con la menor distancia
        if data[min_y, min_x] == data[int(Y[i]), int(X[i])]:
            data[min_y, min_x] = 0
    
    # Crear una máscara para los píxeles restantes > 0 y establecerlos a 1
    arr_mask = data > 0
    data[arr_mask] = 1
    
    # Crear un nuevo PrimaryHDU con los datos modificados y el mismo header
    imgF = fits.PrimaryHDU(data, header=header)
    imgF.writeto(f'Field_Img/mask/mask_group_{grupo}.fits', overwrite=True)
    
    return

'''def verificar_y_procesar(grupo,filtro):
    for filtro in filtros:
        archivo = f'/home/seba/Documents/DECALS/joined_bricks/{grupo}/{grupo}_image_{filtro}.fits'
        if os.path.exists(archivo):
            psf_maker(grupo, filtro)
        else:
            print(f"El archivo para el filtro {filtro} no está disponible.")'''

for g in GL['Group']:
    filtros = filter_sel(g)[0]
    mask(g)
    for filtro in filtros:
        psf_maker(g, filtro)










